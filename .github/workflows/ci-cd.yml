name: CI-CD

on:
  pull_request:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'

env:
  REGISTRY: ghcr.io

concurrency:
  group: "deploy-${{ github.ref }}"
  cancel-in-progress: true

jobs:
  # ---------- CI ----------
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install deps (clean)
        run: npm ci

      - name: Lint
        run: npm run lint --if-present

      - name: Unit tests
        run: npm test --if-present

      - name: Build (optional)
        run: npm run build --if-present

  # ---------- Build & Push Docker to GHCR ----------
  docker:
    if: github.event_name == 'push'
    needs: ci
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Lowercase repo for GHCR
        run: echo "REPO_LC=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

      # ---- SERVER IMAGE ----
      - name: Meta (server)
        id: meta_server
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ env.REPO_LC }}-server
          tags: |
            type=raw,value=main
            type=sha
            type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/') }}

      - name: Build & Push (server)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta_server.outputs.tags }}
          labels: ${{ steps.meta_server.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ---- WEB IMAGE ----
      - name: Meta (web)
        id: meta_web
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ env.REPO_LC }}-web
          tags: |
            type=raw,value=main
            type=sha
            type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/') }}

      - name: Build & Push (web)
        uses: docker/build-push-action@v6
        with:
          context: ./telemed-web
          file: ./telemed-web/Dockerfile
          push: true
          build-args: |
            VITE_API_URL=/api
          tags: ${{ steps.meta_web.outputs.tags }}
          labels: ${{ steps.meta_web.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max


  deploy-local:
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      needs: docker
      runs-on: [self-hosted, deploy]      # <== runner บนเครื่องคุณ ต้องมี label 'deploy'
      permissions:
        contents: read
        packages: read
      steps:
        - uses: actions/checkout@v4

        - name: Lowercase repo again for this job
          run: echo "REPO_LC=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV

        - name: Create .env.prod from Secrets
          shell: bash
          run: |
            cat > .env.prod <<'EOF'
            # ---- dynamic from workflow ----
            REPO_LC=${{ env.REPO_LC }}
            IMAGE_TAG=main

            # ---- App ----
            NODE_ENV=production
            PORT=4005

            # ---- DB ----
            DB_HOST=db
            DB_PORT=3306
            DB_USER=${{ secrets.MYSQL_USER }}
            DB_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            DB_NAME=${{ secrets.MYSQL_DATABASE }}

            # ---- MySQL init ----
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            EOF

        - name: Login GHCR (read)
          run: echo "${{ github.token }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

        - name: Doctor docker
          run: |
            docker version
            docker compose version

        - name: Pull & Up
          run: |
            docker compose --env-file .env.prod -f docker-compose.prod.yml pull
            docker compose --env-file .env.prod -f docker-compose.prod.yml up -d --remove-orphans
            docker image prune -f

        - name: Smoke test API
          shell: bash
          run: |
            for i in {1..30}; do
              if curl -fsS http://localhost:4005/api/health | grep -q '"ok":true'; then
                echo "API healthy"; exit 0
              fi
              echo "wait API... ($i)"; sleep 3
            done
            echo "API NOT healthy"; exit 1

        - name: Smoke test Web
          shell: bash
          run: |
            for i in {1..30}; do
              code=$(curl -s -L -o /dev/null -w "%{http_code}" http://localhost:8080/)
              if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
                echo "Web up ($code)"; exit 0
              fi
              echo "wait Web... ($i)"; sleep 3
            done
            echo "Web NOT up"; exit 1

        - name: Compose logs (on failure)
          if: failure()
          run: |
            docker compose -f docker-compose.prod.yml ps
            docker compose -f docker-compose.prod.yml logs --tail=200

  # ---------- Deploy to self-hosted (prod-like on your machine) ----------
  # deploy-local:
  #   if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main')
  #   needs: docker
  #   runs-on: self-hosted
  #   permissions:
  #     packages: read
  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Create .env.prod from Secrets
  #       run: |
  #         cat > .env.prod <<'EOF'
  #         # --- dynamic from workflow ---
  #         REPO_LC=${{ env.REPO_LC }}
  #         IMAGE_TAG=main

  #         # --- App ---
  #         NODE_ENV=production
  #         PORT=4005

  #         # --- MySQL ---
  #         MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
  #         MYSQL_USER=${{ secrets.MYSQL_USER }}
  #         MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
  #         MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
  #         EOF

  #     - name: Login GHCR (read packages)
  #       env:
  #         GHCR_PAT: ${{ secrets.GHCR_PAT }}
  #       run: |
  #         set -e
  #         if [ -n "${GHCR_PAT:-}" ]; then
  #           echo "$GHCR_PAT" | docker login ghcr.io -u "${GITHUB_ACTOR:-github-actions}" --password-stdin
  #         else
  #           echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${GITHUB_ACTOR:-github-actions}" --password-stdin
  #         fi

  #     - name: Doctor docker
  #       run: |
  #         docker version
  #         docker compose version

  #     - name: Pull & Up
  #       run: |
  #         set -e
  #         docker compose --env-file .env.prod -f docker-compose.prod.yml pull
  #         docker compose --env-file .env.prod -f docker-compose.prod.yml up -d --remove-orphans
  #         docker image prune -f

  #     - name: Smoke test API
  #       run: |
  #         set -e
  #         for i in {1..30}; do
  #           if curl -fsS http://localhost:4005/api/health | grep -q '"ok":true'; then
  #             echo "API healthy"; exit 0
  #           fi
  #           echo "wait API... ($i)"; sleep 3
  #         done
  #         echo "API NOT healthy"; exit 1

  #     - name: Smoke test Web
  #       run: |
  #         set -e
  #         for i in {1..30}; do
  #           code=$(curl -s -L -o /dev/null -w "%{http_code}" http://localhost:8080/)
  #           if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then
  #             echo "Web up ($code)"; exit 0
  #           fi
  #           echo "wait Web... ($i)"; sleep 3
  #         done
  #         echo "Web NOT up"; exit 1

  #     - name: Print compose logs (on failure)
  #       if: failure()
  #       run: |
  #         docker compose -f docker-compose.prod.yml ps
  #         docker compose -f docker-compose.prod.yml logs --tail=200



# ---------- Deploy to EC2 via Docker Compose ----------
  # deploy:
  #   if: github.event_name == 'push'
  #   needs: docker
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v4

  #     - name: Copy compose (prod)
  #       uses: appleboy/scp-action@v0.1.7
  #       with:
  #         host: ${{ secrets.SSH_HOST }}
  #         username: ${{ secrets.SSH_USER }}
  #         key: ${{ secrets.SSH_KEY }}
  #         source: docker-compose.prod.yml
  #         target: "~/app"

  #     - name: Copy db init (if present)
  #       if: ${{ hashFiles('db/init/**') != '' }}
  #       uses: appleboy/scp-action@v0.1.7
  #       with:
  #         host: ${{ secrets.SSH_HOST }}
  #         username: ${{ secrets.SSH_USER }}
  #         key: ${{ secrets.SSH_KEY }}
  #         source: db/init/**
  #         target: "~/app/db/init"


  #     # (ตัวเลือก) สร้างไฟล์ .env บนเครื่องปลายทางจาก Secrets
  #     - name: Write .env on server (optional)
  #       uses: appleboy/ssh-action@v1.2.0
  #       with:
  #         host: ${{ secrets.SSH_HOST }}
  #         username: ${{ secrets.SSH_USER }}
  #         key: ${{ secrets.SSH_KEY }}
  #         script: |
  #           mkdir -p ~/app
  #           cat > ~/app/.env <<'EOF'
  #           MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
  #           MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
  #           EOF

  #     - name: Deploy with compose
  #       uses: appleboy/ssh-action@v1.2.0
  #       with:
  #         host: ${{ secrets.SSH_HOST }}
  #         username: ${{ secrets.SSH_USER }}
  #         key: ${{ secrets.SSH_KEY }}
  #         envs: GHCR_PAT,GITHUB_ACTOR
  #         script: |
  #           set -euo pipefail

  #           # ensure docker installed
  #           if ! command -v docker >/dev/null 2>&1; then
  #             sudo apt-get update -y
  #             sudo apt-get install -y ca-certificates curl gnupg lsb-release
  #             sudo install -m 0755 -d /etc/apt/keyrings
  #             curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  #             echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") $(lsb_release -cs) stable" \
  #               | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
  #             sudo apt-get update -y
  #             sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  #           fi

  #           sudo systemctl enable --now docker
  #           DOCKER="sudo docker"

  #           # login GHCR (ถ้าแพ็กเกจเป็น private)
  #           if [ -n "${GHCR_PAT:-}" ]; then
  #             echo "$GHCR_PAT" | $DOCKER login ghcr.io -u "${GITHUB_ACTOR:-github-actions}" --password-stdin
  #           fi

  #           cd ~/app
  #           # ใช้ .env ถ้ามี (มีหรือไม่มีก็ทำงานได้ เพราะ compose ใส่ default ไว้แล้ว)
  #           if [ -f .env ]; then
  #             $DOCKER compose --env-file .env -f docker-compose.prod.yml pull
  #             $DOCKER compose --env-file .env -f docker-compose.prod.yml up -d
  #           else
  #             $DOCKER compose -f docker-compose.yml pull
  #             $DOCKER compose -f docker-compose.yml up -d
  #           fi

  #           $DOCKER image prune -f

  # # ---------- Optional: Post-Deploy Integration Test ----------
  # post-deploy-test:
  #   if: github.event_name == 'push'
  #   needs: deploy
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Wait for service to be ready
  #       run: |
  #         for i in {1..30}; do
  #           if curl -fsS "${{ secrets.APP_URL }}/api/health" | grep -q '"ok":true'; then
  #             echo "Service healthy"; exit 0
  #           fi
  #           echo "Waiting... ($i)"; sleep 5
  #         done
  #         echo "Service NOT healthy"; exit 1